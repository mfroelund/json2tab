"""Module that handles generation of tab files for wind turbine data."""

import contextlib
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd
from tabulate import tabulate

from .logs import logger
from .TurbineMatcher import TurbineMatcher
from .utils import get_height, get_radius, get_rated_power_kw, print_processing_status


class TurbineLocationTabFileWriter:
    """Handles generation of tab files for wind turbine data."""

    def __init__(self, config: Dict[str, Any], matcher: TurbineMatcher):
        """Initialize writer with configuration."""
        self.config = config

        self.matcher = matcher
        self.location_manager = matcher.turbine_location_manager
        self.type_manager = matcher.turbine_type_manager

    def _write_header(self, file):
        # Collect selection info for header string in output file
        subsetting_config = self.config["subsetting"]
        selection_method = subsetting_config["method"]
        selection_method_details = None

        if selection_method == "bbox":
            selection_method_details = ", ".join(
                str(i) for i in subsetting_config["bbox"]
            )
        elif selection_method == "domain":
            if "name" in subsetting_config["domain"]:
                selection_method_details = subsetting_config["domain"]["name"]
            else:
                selection_method_details = "unnamed_domain"
        elif selection_method == "country":
            selection_method_details = ", ".join(
                c for c in subsetting_config["country"].get("selected_countries", [])
            )

        spaces = f"\n#{' ' * len('     Source(s) for turbine locations:')} - "

        # Write header with extended information
        file.write(
            "# Wind turbine location database generated by "
            f"json2tab on {self.matcher.match_generated}\n"
        )
        file.write(
            "#     Source(s) for turbine locations: - "
            f"{spaces.join(str(p) for p in self.location_manager.location_files)}\n"
        )
        file.write(
            "#     Source(s) for type database:     - "
            f"{spaces.join(str(p) for p in self.type_manager.specs_files)}\n"
        )
        file.write(
            "#     Subdomain selection method:      "
            f"{selection_method}({selection_method_details}) \n"
        )
        file.write(
            "#     Situation date:                  "
            f"{subsetting_config.get('situation_date')} \n"
        )

        file.write("#\n")
        file.write(
            "# This file includes references to an auto-increment type "
            "and the model designation\n"
        )
        file.write(
            "#     lon          lat          type        r         z     # "
            "| country | is_offshore | rated_power | model_designation\n"
        )

    def write(
        self,
        matched_turbines: pd.DataFrame,
        output_name: Optional[str] = None,
        type_idx_key: Optional[str] = None,
    ):
        """Write turbine locations to tab file with enhanced diversification of models."""
        total_turbines = len(matched_turbines.index)

        output_dir = Path(self.config["output"]["directory"])

        if output_name is None:
            output_name = self.config["output"]["files"]["location_tab"]

        if type_idx_key is None:
            type_idx_key = "type_idx"

        output_path = output_dir / output_name
        logger.info(f"Start writing {total_turbines} turbine locations to {output_path}")

        with open(output_path, "w") as file:
            # Write header
            self._write_header(file)

            # Write the actual location data
            skipCounter = 0
            for idx, turbine in matched_turbines.iterrows():
                try:
                    print_processing_status(
                        idx, total_turbines, "Writing turbines in location-tab file"
                    )

                    # Fetch necessary information
                    lon = turbine.get("longitude")
                    lat = turbine.get("latitude")
                    type_idx = turbine.get(type_idx_key)
                    radius = get_radius(turbine)
                    height = get_height(turbine)

                    multiplicity = int(turbine.get("n_turbines", None) or 1)

                    # Fetch optional information
                    country = turbine.get("country")
                    rated_power = get_rated_power_kw(turbine)
                    is_offshore = turbine.get("is_offshore")
                    model_designation = turbine.get(self.matcher.model_designation_key)

                    # Format line with proper spacing and including model designation
                    line = (
                        f"{float(lon):10.4f}   "
                        f"{float(lat):10.4f}   "
                        f"{type_idx:>8}    "
                        f"{radius:>8.2f}   "
                        f"{height:>8.2f}   "
                        "#| "
                        f"{country} | "
                        f"{is_offshore} | "
                        f"{rated_power} | "
                        f"{model_designation}\n"
                    )

                    if self._do_nwp_check(radius, height, model_designation, lon, lat):
                        for _ in range(multiplicity):
                            file.write(line)

                        if multiplicity > 1:
                            logger.warning(
                                f"Written {multiplicity} duplicated lines to represent "
                                f"the wind tubines in wind farm at N{lat} E{lon}."
                            )
                    else:
                        # Note: at the moment the NWP cannot handle commented out
                        # turbines, so completly remove them from the tab-file.
                        logger.warning(
                            f"Basic turbine property checks failed for this turbine(s); "
                            f"so skip this turbine(s) [multiplicity={multiplicity}]. "
                            "Line is removed."
                        )
                        skipCounter += 1

                except Exception as e:
                    logger.exception(f"Error writing location tab file at {idx}: {e}")
                    logger.debug(f"Problematic turbine: {turbine}")
                    continue

            if skipCounter > 0:
                msg = (
                    f"Skipped {skipCounter} turbine{'s' if skipCounter > 1 else ''} "
                    "while writing location data."
                )
                print(f"\nWARNING: {msg}")
                logger.warning(msg)

            logger.info("Finished writing tab file with model references")

    def _do_nwp_check(
        self,
        radius: float,
        height: float,
        model_designation: Optional[str] = None,
        lon: Optional[float] = None,
        lat: Optional[float] = None,
    ):
        """Perform some final checks to see if hub height and radius are reasonable.

        Checks are also perfomed while reading location data in NWP code.
        """
        passed_nwp_checks = True
        if radius < 1 or radius > 500:
            logger.error(
                f"Found wrong radius for {model_designation} at "
                f"({float(lon):10.4f}; {float(lat):10.4f}), radius={radius}"
            )
            passed_nwp_checks = False

        if height < 10 or height > 500:
            logger.error(
                f"Found wrong hubheight for {model_designation} at "
                f"({float(lon):10.4f}; {float(lat):10.4f}), "
                f"hubheight={height}"
            )
            passed_nwp_checks = False

        if radius >= height:
            logger.error(
                f"Found wrong radius/height for {model_designation} at "
                f"({float(lon):10.4f}; {float(lat):10.4f}), "
                f"radius={radius} >= hubheight={height}"
            )
            passed_nwp_checks = False

        return passed_nwp_checks

    def write_installed_capacity_table(self, matched_turbines: pd.DataFrame):
        """Write table with installed capacity for each country."""
        output_dir = Path(self.config["output"]["directory"])

        countries = matched_turbines["country"].unique().tolist()
        data = {
            "Country": countries,
            "Total installed capacity (MW)": len(countries) * [0],
            "Onshore capacity (MW)": len(countries) * [0],
            "Offshore capacity (MW)": len(countries) * [0],
            "Total installed turbines": len(countries) * [0],
            "Onshore turbines": len(countries) * [0],
            "Offshore turbines": len(countries) * [0],
        }

        for label, flag in [
            ("Total installed", None),
            ("Onshore", False),
            ("Offshore", True),
        ]:
            filtered_table = matched_turbines
            if flag is not None:
                filtered_table = matched_turbines[matched_turbines["is_offshore"] == flag]

            with pd.option_context("future.no_silent_downcasting", True):
                filtered_table = filtered_table.fillna({"n_turbines": 1}).infer_objects(
                    copy=False
                )
            filtered_table = filtered_table.assign(
                weighted_power_rating=filtered_table["power_rating"]
                * filtered_table["n_turbines"]
            )

            sub_table = (
                filtered_table.groupby("country")
                .agg({"weighted_power_rating": "sum", "n_turbines": "sum"})
                .reset_index()
            )

            for _, row in sub_table.iterrows():
                idx = countries.index(row["country"])
                data[f"{label} capacity (MW)"][idx] = row["weighted_power_rating"] / 1000
                data[f"{label} turbines"][idx] = row["n_turbines"]

        # Add total line:
        data["Country"].append("Total")
        for field in data.keys() - {"Country"}:
            data[field].append(sum(data[field]))

        stats = pd.DataFrame(data=data)
        stats = stats.sort_values(by=["Total installed capacity (MW)"], ascending=False)
        table = tabulate(stats, headers="keys", tablefmt="psql", showindex=False)

        header_str = "Installed capacity summary: \n\n"
        print(f"\n\n{header_str}{table}")

        with contextlib.suppress(Exception):
            stats.to_csv(output_dir / "installed_capacity.csv", index=False)

            with open(output_dir / "installed_capacity.txt", "w") as file:
                file.write(table)
