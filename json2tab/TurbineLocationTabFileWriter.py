"""Module that handles generation of tab files for wind turbine data."""

import contextlib
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd

from .io.write_statistics import write_statistics
from .logs import logger
from .TurbineMatcher import TurbineMatcher
from .utils import (
    do_nwp_check,
    get_height,
    get_radius,
    get_rated_power_kw,
    print_processing_status,
)


class TurbineLocationTabFileWriter:
    """Handles generation of tab files for wind turbine data."""

    def __init__(self, config: Dict[str, Any], matcher: TurbineMatcher):
        """Initialize writer with configuration."""
        self.config = config

        self.matcher = matcher
        self.location_manager = matcher.turbine_location_manager
        self.type_manager = matcher.turbine_type_manager

        format_config = {}
        with contextlib.suppress(Exception):
            format_config = self.config["output"]["tab_format"]["location"]

        self.precision = format_config.get("precision")
        self.print_line_comment = format_config.get("print_line_comment", False)

        if not isinstance(self.precision, int):
            try:
                self.precision = int(self.precision)
            except (ValueError, TypeError):
                # By default print 4 digits
                self.precision = 4

    def _write_header(self, file):
        # Collect selection info for header string in output file
        subsetting_config = self.config["subsetting"]
        selection_method = subsetting_config["method"]
        selection_method_details = None

        if selection_method == "bbox":
            selection_method_details = ", ".join(
                str(i) for i in subsetting_config["bbox"]
            )
        elif selection_method == "domain":
            if "name" in subsetting_config["domain"]:
                selection_method_details = subsetting_config["domain"]["name"]
            else:
                selection_method_details = "unnamed_domain"
        elif selection_method == "country":
            selection_method_details = ", ".join(
                c for c in subsetting_config["country"].get("selected_countries", [])
            )

        spaces = f"\n#{' ' * len('     Source(s) for turbine locations:')} - "

        # Write header with extended information
        file.write(
            "# Wind turbine location database generated by "
            f"json2tab on {self.matcher.match_generated}\n"
        )
        file.write(
            "#     Source(s) for turbine locations: - "
            f"{spaces.join(str(p) for p in self.location_manager.location_files)}\n"
        )
        file.write(
            "#     Source(s) for type database:     - "
            f"{spaces.join(str(p) for p in self.type_manager.specs_files)}\n"
        )
        file.write(
            "#     Subdomain selection method:      "
            f"{selection_method}({selection_method_details}) \n"
        )
        file.write(
            "#     Situation date:                  "
            f"{subsetting_config.get('situation_date')} \n"
        )

        file.write("#\n")
        file.write(
            "# This file includes references to an auto-increment type "
            "and the model designation\n"
        )

        header_line = "#     lon          lat          type        r         z     "
        if self.print_line_comment:
            header_line += "# | country | is_offshore | rated_power | model_designation"

        file.write(f"{header_line}\n")

    def write(
        self,
        matched_turbines: pd.DataFrame,
        output_name: Optional[str] = None,
        type_idx_key: Optional[str] = None,
    ):
        """Write turbine locations to tab file with enhanced diversification of models."""
        total_turbines = len(matched_turbines.index)

        output_dir = Path(self.config["output"]["directory"])

        if output_name is None:
            output_name = self.config["output"]["files"]["location_tab"]

        if type_idx_key is None:
            type_idx_key = "type_idx"

        output_path = output_dir / output_name
        logger.info(f"Start writing {total_turbines} turbine locations to {output_path}")

        with open(output_path, "w") as file:
            # Write header
            self._write_header(file)

            # Write the actual location data
            skipCounter = 0
            turbine_counter = 0
            for idx, turbine in matched_turbines.iterrows():
                turbine_counter += 1
                try:
                    print_processing_status(
                        turbine_counter,
                        total_turbines,
                        "Writing turbines in location-tab file",
                    )

                    # Fetch necessary information
                    lon = turbine.get("longitude")
                    lat = turbine.get("latitude")
                    type_idx = turbine.get(type_idx_key)
                    radius = get_radius(turbine)
                    height = get_height(turbine)

                    multiplicity = int(turbine.get("n_turbines", None) or 1)

                    # Fetch optional information
                    country = turbine.get("country")
                    rated_power = get_rated_power_kw(turbine, guess_unit=False)
                    is_offshore = turbine.get("is_offshore")
                    model_designation = turbine.get(self.matcher.model_designation_key)

                    tag_str = (
                        f"N{lat}, E{lon} "
                        f"({country}, {'off' if is_offshore else 'on'}shore)"
                    )

                    if model_designation is not None:
                        # Format line with proper spacing
                        line = (
                            f"{float(lon):10.{self.precision}f}   "
                            f"{float(lat):10.{self.precision}f}   "
                            f"{type_idx:>8}    "
                            f"{radius:>8.2f}   "
                            f"{height:>8.2f}"
                        )

                        if self.print_line_comment:
                            # Format line with additional debug info
                            line += (
                                "   #| "
                                f"{country} | "
                                f"{is_offshore} | "
                                f"{rated_power} | "
                                f"{model_designation}"
                            )

                        nwp_passed, msg = do_nwp_check(radius, height)
                        if nwp_passed:
                            for _ in range(multiplicity):
                                file.write(f"{line}\n")

                            if multiplicity > 1:
                                logger.warning(
                                    f"Written {multiplicity} duplicated lines to "
                                    f"represent the wind tubines in "
                                    f"wind farm at {tag_str}."
                                )
                        else:
                            logger.error(
                                f"Found {msg} for {model_designation} at "
                                f"(N{lat}, E{lon}), radius={radius}"
                            )

                            # Note: at the moment the NWP cannot handle commented out
                            # turbines, so completly remove them from the tab-file.
                            logger.warning(
                                f"Basic NWP turbine property checks failed for this "
                                "turbine(s); so skip this turbine(s) "
                                f"[multiplicity={multiplicity}]. Line is removed."
                            )
                            skipCounter += 1
                    else:
                        logger.warning(
                            f"No turbine type matched for wind turbine at {tag_str}; "
                            f"so skip this turbine(s) [multiplicity={multiplicity}]. "
                            "Line is removed."
                        )
                        skipCounter += 1

                except Exception as e:
                    logger.exception(f"Error writing location tab file at {idx}: {e}")
                    logger.debug(f"Problematic turbine: {turbine}")
                    continue

            if skipCounter > 0:
                msg = (
                    f"Skipped {skipCounter} turbine{'s' if skipCounter > 1 else ''} "
                    "while writing location data."
                )
                print(f"Note: {msg}")
                logger.warning(msg)

            logger.info("Finished writing turbine location tab file.")

    def write_installed_capacity_table(self, matched_turbines: pd.DataFrame):
        """Write table with installed capacity for each country."""
        output_dir = Path(self.config["output"]["directory"])

        countries = matched_turbines["country"].unique().tolist()
        data = {
            "Country": countries,
            "Total installed capacity (MW)": len(countries) * [0],
            "Onshore capacity (MW)": len(countries) * [0],
            "Offshore capacity (MW)": len(countries) * [0],
            "Total installed turbines": len(countries) * [0],
            "Onshore turbines": len(countries) * [0],
            "Offshore turbines": len(countries) * [0],
        }

        for label, flag in [
            ("Total installed", None),
            ("Onshore", False),
            ("Offshore", True),
        ]:
            filtered_table = matched_turbines
            if flag is not None:
                filtered_table = matched_turbines[matched_turbines["is_offshore"] == flag]

            with pd.option_context("future.no_silent_downcasting", True):
                filtered_table = filtered_table.fillna({"n_turbines": 1}).infer_objects(
                    copy=False
                )
            filtered_table = filtered_table.assign(
                weighted_power_rating=filtered_table["power_rating"]
                * filtered_table["n_turbines"]
            )

            sub_table = (
                filtered_table.groupby("country")
                .agg({"weighted_power_rating": "sum", "n_turbines": "sum"})
                .reset_index()
            )

            for _, row in sub_table.iterrows():
                idx = countries.index(row["country"])
                data[f"{label} capacity (MW)"][idx] = row["weighted_power_rating"] / 1000
                data[f"{label} turbines"][idx] = row["n_turbines"]

        # Add total line:
        data["Country"].append("Total")
        for field in data.keys() - {"Country"}:
            data[field].append(sum(data[field]))

        stats = pd.DataFrame(data=data)
        stats = stats.sort_values(by=["Total installed capacity (MW)"], ascending=False)

        table = None
        with contextlib.suppress(Exception):
            filename = self.config["output"]["files"].get("installed_capacity")
            table = write_statistics(stats, output_dir, filename)

        header_str = "Installed capacity summary: \n\n"
        print(f"\n\n{header_str}{table}")
